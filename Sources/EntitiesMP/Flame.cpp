/*
 * This file is generated by Entity Class Compiler, (c) CroTeam 1997-98
 */

#line 4 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"

#include "StdH.h"
#define TM_APPLY_DAMAGE_QUANTUM 0.25f
#define TM_APPLY_WHOLE_DAMAGE 7.5f
#define DAMAGE_AMMOUNT 30.0f
#define MIN_DAMAGE_QUANTUM (DAMAGE_AMMOUNT/TM_APPLY_WHOLE_DAMAGE*TM_APPLY_DAMAGE_QUANTUM)
#define MAX_DAMAGE_QUANTUM (MIN_DAMAGE_QUANTUM*10.0f)
#define DEATH_BURN_TIME 4.0f

#include "EntitiesMP/MovingBrush.h"

#include <EntitiesMP/Flame.h>
#include <EntitiesMP/Flame_tables.h>
CEntityEvent *EFlame::MakeCopy(void) { CEntityEvent *peeCopy = new EFlame(*this); return peeCopy;}
EFlame::EFlame() : CEntityEvent(EVENTCODE_EFlame) {;
 ClearToDefault(penOwner);
 ClearToDefault(penAttach);
};
CEntityEvent *EStopFlaming::MakeCopy(void) { CEntityEvent *peeCopy = new EStopFlaming(*this); return peeCopy;}
EStopFlaming::EStopFlaming() : CEntityEvent(EVENTCODE_EStopFlaming) {;
 ClearToDefault(m_bNow);
};
#line 29 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"

void CFlame_OnPrecache(CDLLEntityClass *pdec, INDEX iUser) 
{
  pdec->PrecacheModel(MODEL_FLAME);
  pdec->PrecacheTexture(TEXTURE_FLAME);
  pdec->PrecacheSound(SOUND_FLAME);
}

void CFlame::SetDefaultProperties(void) {
  m_penOwner = NULL;
  m_penAttach = NULL;
  m_bLoop = FALSE ;
  m_vHitPoint = FLOAT3D(0.0f , 0.0f , 0.0f);
  m_soEffect.SetOwner(this);
m_soEffect.Stop_internal();
  m_tmStart = 0.0f;
  m_fDamageToApply = 0.0f;
  m_fDamageStep = 0.0f;
  m_fAppliedDamage = 0.0f;
  m_tmFirstStart = 0.0f;
  m_ctFlames = 0;
  m_vPos01 = FLOAT3D(0 , 0 , 0);
  m_vPos02 = FLOAT3D(0 , 0 , 0);
  m_vPos03 = FLOAT3D(0 , 0 , 0);
  m_vPos04 = FLOAT3D(0 , 0 , 0);
  m_vPos05 = FLOAT3D(0 , 0 , 0);
  m_vPos06 = FLOAT3D(0 , 0 , 0);
  m_vPos07 = FLOAT3D(0 , 0 , 0);
  m_vPos08 = FLOAT3D(0 , 0 , 0);
  m_vPos09 = FLOAT3D(0 , 0 , 0);
  m_vPos10 = FLOAT3D(0 , 0 , 0);
  m_vPlaneNormal = FLOAT3D(0 , 0 , 0);
  m_bBurningBrush = FALSE ;
  m_tmDeathParticlesStart = 1e6;
  m_penPrediction = NULL;
  CMovableModelEntity::SetDefaultProperties();
}
  
#line 88 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
void CFlame::AddDependentsToPrediction(void) 
#line 89 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 90 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_penOwner  -> AddToPrediction  ();
#line 91 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
  
#line 93 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
void CFlame::PostMoving(void) {
#line 94 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
CMovableModelEntity  :: PostMoving  ();
#line 97 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
CContentType  & ctDn  = GetWorld  () -> wo_actContentTypes  [ en_iDnContent  ];
#line 99 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
if(! (ctDn  . ct_ulFlags  & CTF_BREATHABLE_LUNGS )){
#line 100 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
EStopFlaming  esf ;
#line 101 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
esf  . m_bNow  = TRUE ;
#line 102 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
SendEvent  (esf );
#line 103 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
#line 106 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
en_ulFlags  &= ~ ENF_INRENDERING ;
#line 108 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
en_plLastPlacement  = en_plPlacement ;
#line 109 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
  
#line 112 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
void CFlame::Read_t(CTStream * istr) 
#line 113 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 114 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
CMovableModelEntity  :: Read_t  (istr );
#line 115 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
SetupLightSource  ();
#line 116 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
  
#line 118 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
BOOL CFlame::IsPointInsidePolygon(const FLOAT3D & vPos,CBrushPolygon * pbpo) 
#line 119 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 120 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
FLOATplane3D & plPlane  = pbpo  -> bpo_pbplPlane  -> bpl_plAbsolute ;
#line 122 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
INDEX iMajorAxis1  , iMajorAxis2 ;
#line 123 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
GetMajorAxesForPlane  (plPlane  , iMajorAxis1  , iMajorAxis2 );
#line 126 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
CIntersector  isIntersector  (vPos  (iMajorAxis1 ) , vPos  (iMajorAxis2 ));
#line 128 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
FOREACHINSTATICARRAY  (pbpo  -> bpo_abpePolygonEdges  , CBrushPolygonEdge  , itbpePolygonEdge ){
#line 130 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
const FLOAT3D & vVertex0  = itbpePolygonEdge  -> bpe_pbedEdge  -> bed_pbvxVertex0  -> bvx_vAbsolute ;
#line 131 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
const FLOAT3D & vVertex1  = itbpePolygonEdge  -> bpe_pbedEdge  -> bed_pbvxVertex1  -> bvx_vAbsolute ;
#line 133 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
isIntersector  . AddEdge  (
#line 134 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
vVertex0  (iMajorAxis1 ) , vVertex0  (iMajorAxis2 ) , 
#line 135 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
vVertex1  (iMajorAxis1 ) , vVertex1  (iMajorAxis2 ));
#line 136 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
#line 138 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
return isIntersector  . IsIntersecting  ();
#line 139 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
  
#line 142 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
CLightSource * CFlame::GetLightSource(void) 
#line 143 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 144 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
if(! IsPredictor  ()){
#line 145 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
return & m_lsLightSource ;
#line 146 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}else {
#line 147 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
return NULL ;
#line 148 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
#line 149 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
  
#line 152 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
void CFlame::RenderParticles(void) 
#line 153 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 154 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
FLOAT fTimeFactor  = CalculateRatio  (_pTimer  -> CurrentTick  () , m_tmFirstStart  , m_tmStart  + TM_APPLY_WHOLE_DAMAGE  , 0.05f , 0.2f);
#line 155 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
FLOAT fDeathFactor  = 1.0f;
#line 156 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
if(_pTimer  -> CurrentTick  () > m_tmDeathParticlesStart )
#line 157 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 158 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
fDeathFactor  = 1.0f - Clamp  ((_pTimer  -> CurrentTick  () - m_tmDeathParticlesStart ) / DEATH_BURN_TIME  , 0.0f , 1.0f);
#line 159 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
#line 160 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
CEntity  * penParent  = GetParent  ();
#line 161 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
FLOAT fPower  = ClampUp  (m_fDamageStep  - MIN_DAMAGE_QUANTUM  , MAX_DAMAGE_QUANTUM ) / MAX_DAMAGE_QUANTUM ;
#line 162 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
if(penParent  != NULL )
#line 163 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 164 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
if((penParent  -> en_RenderType  == CEntity  :: RT_MODEL  || penParent  -> en_RenderType  == CEntity  :: RT_EDITORMODEL  || 
#line 165 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
penParent  -> en_RenderType  == CEntity  :: RT_SKAMODEL  || penParent  -> en_RenderType  == CEntity  :: RT_SKAEDITORMODEL ) && 
#line 166 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
(Particle_GetViewer  () != penParent ))
#line 167 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 168 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
Particles_Burning  (penParent  , fPower  , fTimeFactor  * fDeathFactor );
#line 169 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
#line 170 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
else 
#line 171 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 172 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
Particles_BrushBurning  (this  , & m_vPos01  , m_ctFlames  , m_vPlaneNormal  , fPower  , fTimeFactor  * fDeathFactor );
#line 173 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
#line 174 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
#line 175 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
  
#line 178 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
void CFlame::SetupLightSource(void) 
#line 179 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 181 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
CLightSource  lsNew ;
#line 182 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
lsNew  . ls_ulFlags  = LSF_NONPERSISTENT  | LSF_DYNAMIC ;
#line 183 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
if(m_bBurningBrush )
#line 184 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 185 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
UBYTE  ubRndH  = UBYTE  (25 + (FLOAT (rand  ()) / RAND_MAX  - 0.5f) * 28);
#line 186 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
UBYTE  ubRndS  = 166;
#line 187 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
UBYTE  ubRndV  = 48;
#line 188 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
lsNew  . ls_colColor  = HSVToColor  (ubRndH  , ubRndS  , ubRndV );
#line 190 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
lsNew  . ls_rFallOff  = 4.0f;
#line 191 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
lsNew  . ls_rHotSpot  = 0.2f;
#line 192 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
#line 193 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
else 
#line 194 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 195 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
lsNew  . ls_colColor  = 0x8F8F5000;
#line 196 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
lsNew  . ls_rFallOff  = 6.0f;
#line 197 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
lsNew  . ls_rHotSpot  = 0.50f;
#line 198 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
#line 199 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
lsNew  . ls_plftLensFlare  = NULL ;
#line 200 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
lsNew  . ls_ubPolygonalMask  = 0;
#line 201 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
lsNew  . ls_paoLightAnimation  = NULL ;
#line 203 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_lsLightSource  . ls_penEntity  = this ;
#line 204 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_lsLightSource  . SetLightSource  (lsNew );
#line 205 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
BOOL CFlame::
#line 212 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
Main(const CEntityEvent &__eeInput) {
#undef STATE_CURRENT
#define STATE_CURRENT STATE_CFlame_Main
  ASSERTMSG(__eeInput.ee_slEvent==EVENTCODE_EFlame, "CFlame::Main expects 'EFlame' as input!");  const EFlame &ef = (const EFlame &)__eeInput;
#line 214 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
ASSERT  (ef  . penOwner  != NULL );
#line 215 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
ASSERT  (ef  . penAttach  != NULL );
#line 216 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_penOwner  = ef  . penOwner ;
#line 217 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_penAttach  = ef  . penAttach ;
#line 219 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_tmStart  = _pTimer  -> CurrentTick  ();
#line 220 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_tmFirstStart  = m_tmStart ;
#line 221 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
SetParent  (ef  . penAttach );
#line 223 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
InitAsEditorModel  ();
#line 224 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
SetPhysicsFlags  (EPF_MODEL_FLYING );
#line 225 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
SetCollisionFlags  (ECF_FLAME );
#line 226 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
SetFlags  (GetFlags  () | ENF_SEETHROUGH );
#line 228 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
SetModel  (MODEL_FLAME );
#line 229 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
SetModelMainTexture  (TEXTURE_FLAME );
#line 230 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
ModelChangeNotify  ();
#line 233 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_soEffect  . Set3DParameters  (10.0f , 1.0f , 1.0f , 1.0f);
#line 234 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
PlaySound  (m_soEffect  , SOUND_FLAME  , SOF_3D  | SOF_LOOP );
#line 237 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
AddToMovers  ();
#line 239 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_bBurningBrush  = FALSE ;
#line 240 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
BOOL bAllowFlame  = TRUE ;
#line 241 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
if(! (ef  . penAttach  -> en_RenderType  == CEntity  :: RT_MODEL  || ef  . penAttach  -> en_RenderType  == CEntity  :: RT_EDITORMODEL  || 
#line 242 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
ef  . penAttach  -> en_RenderType  == CEntity  :: RT_SKAMODEL  || ef  . penAttach  -> en_RenderType  == CEntity  :: RT_SKAEDITORMODEL ))
#line 243 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 244 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_bBurningBrush  = TRUE ;
#line 245 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
FLOAT3D vPos  = GetPlacement  () . pl_PositionVector ;
#line 246 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
FLOATplane3D plPlane ;
#line 247 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
FLOAT fDistanceToEdge ;
#line 248 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
FindSectorsAroundEntity  ();
#line 249 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
CBrushPolygon  * pbpo  = NULL ;
#line 250 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
pbpo  = GetNearestPolygon  (vPos  , plPlane  , fDistanceToEdge );
#line 251 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
FLOAT3D vBrushPos  = ef  . penAttach  -> GetPlacement  () . pl_PositionVector ;
#line 252 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
FLOATmatrix3D mBrushRotInv  = ! ef  . penAttach  -> GetRotationMatrix  ();
#line 253 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
if(pbpo  != NULL  && pbpo  -> bpo_pbscSector  -> bsc_pbmBrushMip  -> bm_pbrBrush  -> br_penEntity  == ef  . penAttach )
#line 254 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 255 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
plPlane  = pbpo  -> bpo_pbplPlane  -> bpl_plAbsolute ;
#line 256 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_vPlaneNormal  = (FLOAT3D &) plPlane ;
#line 257 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_vPlaneNormal  . Normalize  ();
#line 259 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
FLOAT3D vU  , vV ;
#line 261 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
if(plPlane  (2) < - 0.1f)
#line 262 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 263 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
bAllowFlame  = FALSE ;
#line 264 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
#line 267 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
if(Abs  (plPlane  (2)) > 0.5){
#line 269 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
vU  = FLOAT3D (1.0f , 0.0f , 0.0f) * m_vPlaneNormal ;
#line 271 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}else {
#line 273 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
vU  = FLOAT3D (0.0f , 1.0f , 0.0f) * m_vPlaneNormal ;
#line 274 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
#line 276 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
vU  . Normalize  ();
#line 278 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
vV  = vU  * m_vPlaneNormal ;
#line 279 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
vV  . Normalize  ();
#line 282 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_ctFlames  = 0;
#line 283 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
for(INDEX iTest  = 0;iTest  < 20;iTest  ++)
#line 284 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 285 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
FLOAT fA  = FRnd  () * 360.0f;
#line 286 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
FLOAT fR  = FRnd  () * 2.0f;
#line 287 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
FLOAT3D vRndV  = vV  * fR  * SinFast  (fA );
#line 288 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
FLOAT3D vRndU  = vU  * fR  * CosFast  (fA );
#line 289 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
FLOAT3D vRndPos  = vPos ;
#line 290 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
if(iTest  != 0)
#line 291 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 292 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
vRndPos  += vRndV  + vRndU ;
#line 293 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
#line 295 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
FLOAT3D vProjectedRndPos  = plPlane  . ProjectPoint  (vRndPos );
#line 296 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
if(IsPointInsidePolygon  (vProjectedRndPos  , pbpo ))
#line 297 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 298 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
(& m_vPos01 ) [ m_ctFlames  ] = (vProjectedRndPos  - vBrushPos ) * mBrushRotInv ;
#line 299 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_ctFlames  ++;
#line 300 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
if(m_ctFlames  == 6){break ;};
#line 301 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
#line 302 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
#line 303 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
#line 304 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
else 
#line 305 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 306 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
bAllowFlame  = FALSE ;
#line 307 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
#line 308 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
#line 310 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
if(bAllowFlame )
#line 311 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 312 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
SetupLightSource  ();
#line 313 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
#line 315 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_bLoop  = bAllowFlame ;
#line 316 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
Jump(STATE_CURRENT,0x01f80004, FALSE, EInternal());return TRUE;}BOOL CFlame::H0x01f80004_Main_03(const CEntityEvent &__eeInput){
ASSERT(__eeInput.ee_slEvent==EVENTCODE_EInternal);
#undef STATE_CURRENT
#define STATE_CURRENT 0x01f80004
if(!(m_bLoop )){ Jump(STATE_CURRENT,0x01f80005, FALSE, EInternal());return TRUE;}
#line 317 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
SetTimerAfter(TM_APPLY_DAMAGE_QUANTUM );
Jump(STATE_CURRENT, 0x01f80002, FALSE, EBegin());return TRUE;}BOOL CFlame::H0x01f80002_Main_01(const CEntityEvent &__eeInput) {
#undef STATE_CURRENT
#define STATE_CURRENT 0x01f80002
switch(__eeInput.ee_slEvent){case(EVENTCODE_EBegin):{const EBegin&e= (EBegin&)__eeInput;

#line 321 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
if(m_penAttach  == NULL  || (m_penAttach  -> GetFlags  () & ENF_DELETED )){
#line 323 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_bLoop  = FALSE ;
#line 324 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
UnsetTimer();Jump(STATE_CURRENT,0x01f80003, FALSE, EInternal());return TRUE;
#line 325 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
#line 327 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
const FLOAT fDamageMul  = GetSeriousDamageMultiplier  (m_penOwner );
#line 328 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
FLOAT fDamageToApply  = fDamageMul  * (m_fDamageToApply  / TM_APPLY_WHOLE_DAMAGE  * TM_APPLY_DAMAGE_QUANTUM ) * m_fDamageStep ;
#line 329 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_penAttach  -> InflictDirectDamage  (m_penAttach  , m_penOwner  , DMT_BURNING  , fDamageToApply  , 
#line 330 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
GetPlacement  () . pl_PositionVector  , - en_vGravityDir );
#line 331 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_fAppliedDamage  += fDamageToApply ;
#line 332 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
return TRUE;
#line 333 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}ASSERT(FALSE);break;case(EVENTCODE_EFlame):{const EFlame&ef= (EFlame&)__eeInput;

#line 335 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_penOwner  = ef  . penOwner ;
#line 336 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
FLOAT fTimeLeft  = m_tmStart  + TM_APPLY_WHOLE_DAMAGE  - _pTimer  -> CurrentTick  ();
#line 337 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
FLOAT fDamageLeft  = (fTimeLeft  / TM_APPLY_DAMAGE_QUANTUM ) * m_fDamageStep ;
#line 338 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_fDamageToApply  = ClampUp  (fDamageLeft  + DAMAGE_AMMOUNT  , 80.0f);
#line 339 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_tmStart  = _pTimer  -> CurrentTick  ();
#line 340 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_fDamageStep  = m_fDamageToApply  / (TM_APPLY_WHOLE_DAMAGE  / TM_APPLY_DAMAGE_QUANTUM );
#line 341 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
return TRUE;
#line 342 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}ASSERT(FALSE);break;case(EVENTCODE_EStopFlaming):{const EStopFlaming&esf= (EStopFlaming&)__eeInput;

#line 344 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
if(! esf  . m_bNow )
#line 345 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 346 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_tmDeathParticlesStart  = _pTimer  -> CurrentTick  ();
#line 347 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
return TRUE;
#line 348 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
#line 349 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
else 
#line 350 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 351 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_bLoop  = FALSE ;
#line 352 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
UnsetTimer();Jump(STATE_CURRENT,0x01f80003, FALSE, EInternal());return TRUE;
#line 353 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}
#line 354 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}ASSERT(FALSE);break;case(EVENTCODE_EBrushDestroyed):{const EBrushDestroyed&e= (EBrushDestroyed&)__eeInput;

#line 356 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_bLoop  = FALSE ;
#line 357 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
UnsetTimer();Jump(STATE_CURRENT,0x01f80003, FALSE, EInternal());return TRUE;
#line 358 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}ASSERT(FALSE);break;case(EVENTCODE_ETimer):{const ETimer&e= (ETimer&)__eeInput;
UnsetTimer();Jump(STATE_CURRENT,0x01f80003, FALSE, EInternal());return TRUE;}ASSERT(FALSE);break;default: return FALSE; break;
#line 360 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}return TRUE;}BOOL CFlame::H0x01f80003_Main_02(const CEntityEvent &__eeInput){
ASSERT(__eeInput.ee_slEvent==EVENTCODE_EInternal);
#undef STATE_CURRENT
#define STATE_CURRENT 0x01f80003

#line 361 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
if(_pTimer  -> CurrentTick  () > m_tmStart  + TM_APPLY_WHOLE_DAMAGE )
#line 362 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
{
#line 363 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
m_bLoop  = FALSE ;
#line 364 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}Jump(STATE_CURRENT,0x01f80004, FALSE, EInternal());return TRUE;
#line 365 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
}BOOL CFlame::H0x01f80005_Main_04(const CEntityEvent &__eeInput) {
ASSERT(__eeInput.ee_slEvent==EVENTCODE_EInternal);
#undef STATE_CURRENT
#define STATE_CURRENT 0x01f80005

#line 368 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
Destroy  ();
#line 369 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
Return(STATE_CURRENT,EVoid());
#line 369 "D:/SE1_GPL/Sources/EntitiesMP/Flame.es"
return TRUE; ASSERT(FALSE); return TRUE;};